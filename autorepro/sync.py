#!/usr/bin/env python3
"""
AutoRepro sync module for generic comment/content synchronization.

Provides reusable functionality for both issue and PR sync block management.
"""

from __future__ import annotations

import json
import re
from datetime import datetime
from typing import Any, Literal, NamedTuple


class ReportMeta(NamedTuple):
    """Metadata for report attachment."""

    filename: str
    size_bytes: int
    path: str


def render_sync_comment(
    plan_content: str,
    format_type: str,
    context: Literal["issue", "pr"] = "issue",
    *,
    attach_report: ReportMeta | None = None,
    links: list[str] | None = None,
    summary: str | None = None,
    use_details: bool = True,
) -> str:
    """
    Render sync comment for either issues or PRs with tagged sync block.

    Args:
        plan_content: The plan content (markdown or JSON)
        format_type: Format type ('md' or 'json')
        context: Context for rendering ('issue' or 'pr')
        attach_report: Optional report metadata to include
        links: Optional list of cross-reference links
        summary: Optional short summary for context
        use_details: Whether to wrap long content in collapsible details

    Returns:
        Formatted comment body with sync block tags
    """
    # Build header section
    header_lines = []

    # Extract title from content
    title = _extract_title_from_content(plan_content, format_type)

    # Context-specific headers
    if context == "pr":
        header_lines.append(f"## ðŸ”„ {title}")
        if summary:
            header_lines.append(f"**Context**: {summary}")
            header_lines.append("")
        header_lines.append("**Summary**: AutoRepro reproduction plan for this PR")
    else:
        header_lines.append(f"## {title}")
        header_lines.append("**Summary**: AutoRepro plan generated from issue description")

    header_lines.append("")

    # Add cross-reference links if provided
    if links:
        header_lines.append("**Related**:")
        for link in links:
            header_lines.append(f"- {link}")
        header_lines.append("")

    # Add report attachment info if provided
    if attach_report:
        header_lines.append("**Report Bundle**:")
        header_lines.append(f"- File: `{attach_report.filename}`")
        header_lines.append(f"- Size: {attach_report.size_bytes:,} bytes")
        header_lines.append(f"- Path: `{attach_report.path}`")
        header_lines.append("")
        header_lines.append(
            "*Note: Report bundle contains plan, environment info, and execution logs.*"
        )
        header_lines.append("")

    # Determine if content should be wrapped in details
    content_lines = plan_content.strip().split("\n")
    should_use_details = use_details and len(content_lines) > 15

    # Build sync block content
    if should_use_details:
        sync_block_lines = [
            "<!-- autorepro:begin plan schema=1 -->",
            "<details>",
            "<summary>ðŸ“‹ Reproduction Plan (click to expand)</summary>",
            "",
            plan_content.rstrip(),
            "",
            "</details>",
            "<!-- autorepro:end plan -->",
        ]
    else:
        sync_block_lines = [
            "<!-- autorepro:begin plan schema=1 -->",
            plan_content.rstrip(),
            "<!-- autorepro:end plan -->",
        ]

    # Add generation timestamp
    timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ")
    footer_lines = [
        "",
        f"<!-- generated: {timestamp} -->",
        "",
        "*Generated by [AutoRepro](https://github.com/ali90h/AutoRepro)*",
    ]

    # Combine all sections
    all_lines = header_lines + sync_block_lines + footer_lines
    return "\n".join(all_lines)


def find_synced_block(text: str) -> tuple[int, int] | None:
    """
    Find the autorepro sync block boundaries in text.

    Args:
        text: Text to search

    Returns:
        Tuple of (start_index, end_index) if found, None otherwise.
        Indices point to character positions of the begin/end tags.
    """
    # Look for the sync block tags
    begin_pattern = r"<!-- autorepro:begin plan schema=1 -->"
    end_pattern = r"<!-- autorepro:end plan -->"

    begin_match = re.search(begin_pattern, text)
    if not begin_match:
        return None

    end_match = re.search(end_pattern, text[begin_match.end() :])
    if not end_match:
        return None

    return begin_match.start(), begin_match.end() + end_match.end()


def replace_synced_block(existing_text: str, new_plan_content: str) -> str:
    """
    Replace the synced block content in existing text.

    Args:
        existing_text: The existing text with sync block
        new_plan_content: New plan content to insert

    Returns:
        Updated text with replaced sync block
    """
    block_bounds = find_synced_block(existing_text)
    if not block_bounds:
        # If no existing sync block, append new block
        new_sync_block = f"""
<!-- autorepro:begin plan schema=1 -->
{new_plan_content.rstrip()}
<!-- autorepro:end plan -->"""
        return existing_text.rstrip() + new_sync_block

    start_idx, end_idx = block_bounds

    # Replace just the sync block content
    new_sync_block = (
        f"<!-- autorepro:begin plan schema=1 -->\n{new_plan_content.rstrip()}\n"
        "<!-- autorepro:end plan -->"
    )

    return existing_text[:start_idx] + new_sync_block + existing_text[end_idx:]


def find_autorepro_content(content_list: list[dict[str, Any]]) -> dict[str, Any] | None:
    """
    Find existing autorepro content in list of comments or PR data.

    Args:
        content_list: List of content objects (comments, etc.) from GitHub

    Returns:
        Content object if found, None otherwise
    """
    for content in content_list:
        body = content.get("body", "")
        if "<!-- autorepro:begin plan schema=1 -->" in body:
            return content
    return None


def _extract_title_from_content(plan_content: str, format_type: str) -> str:
    """Extract title from plan content."""
    if format_type == "json":
        try:
            plan_data = json.loads(plan_content)
            return plan_data.get("title", "Issue Reproduction Plan")
        except json.JSONDecodeError:
            return "Issue Reproduction Plan"
    else:
        # Extract title from markdown
        lines = plan_content.split("\n")
        title_line = next(
            (line for line in lines if line.startswith("# ")), "# Issue Reproduction Plan"
        )
        return title_line[2:].strip()


def build_cross_reference_links(
    context: Literal["issue", "pr"] = "issue",
    *,
    link_issue: int | None = None,
    link_pr: int | None = None,
) -> list[str]:
    """
    Build list of cross-reference links.

    Args:
        context: Context for linking ('issue' or 'pr')
        link_issue: Issue number to link to
        link_pr: PR number to link to

    Returns:
        List of formatted cross-reference links
    """
    links = []

    if context == "pr" and link_issue:
        links.append(f"Relates to #{link_issue}")
    elif context == "issue" and link_pr:
        links.append(f"Relates to #{link_pr}")

    return links
