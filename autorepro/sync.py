#!/usr/bin/env python3
"""
AutoRepro sync module for generic comment/content synchronization.

Provides reusable functionality for both issue and PR sync block management.
"""

from __future__ import annotations

import json
import re
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Literal, NamedTuple


@dataclass
class SyncCommentConfig:
    """Configuration for sync comment rendering."""

    plan_content: str
    format_type: str
    context: Literal["issue", "pr"] = "issue"
    attach_report: ReportMeta | None = None
    links: list[str] | None = None
    summary: str | None = None
    use_details: bool = True


class ReportMeta(NamedTuple):
    """Metadata for report attachment."""

    filename: str
    size_bytes: int
    path: str


def render_sync_comment(
    config_or_content: SyncCommentConfig | str,
    format_type: str | None = None,
    context: Literal["issue", "pr"] | None = None,
    *,
    attach_report: ReportMeta | None = None,
    links: list[str] | None = None,
    summary: str | None = None,
    use_details: bool = True,
) -> str:
    """
    Render sync comment for either issues or PRs with tagged sync block.

    Args:
        config_or_content: Either a SyncCommentConfig object or plan content string
        format_type: Format type (required if first arg is string)
        context: Context type (required if first arg is string)
        attach_report: Report metadata for attachment
        links: Cross-reference links
        summary: Summary text
        use_details: Whether to use details sections for long content

    Returns:
        Formatted comment body with sync block tags
    """
    # Handle backward compatibility - support both old and new signatures
    if isinstance(config_or_content, str):
        if format_type is None or context is None:
            raise TypeError(
                "format_type and context are required when passing plan content as string"
            )
        config = SyncCommentConfig(
            plan_content=config_or_content,
            format_type=format_type,
            context=context,
            attach_report=attach_report,
            links=links,
            summary=summary,
            use_details=use_details,
        )
    else:
        config = config_or_content
    # Build header section
    header_lines = []

    # Extract title from content
    title = _extract_title_from_content(config.plan_content, config.format_type)

    # Context-specific headers
    if config.context == "pr":
        header_lines.append(f"## ðŸ”„ {title}")
        if config.summary:
            header_lines.append(f"**Context**: {config.summary}")
            header_lines.append("")
        header_lines.append("**Summary**: AutoRepro reproduction plan for this PR")
    else:
        header_lines.append(f"## {title}")
        header_lines.append("**Summary**: AutoRepro plan generated from issue description")

    header_lines.append("")

    # Add cross-reference links if provided
    if config.links:
        header_lines.append("**Related**:")
        for link in config.links:
            header_lines.append(f"- {link}")
        header_lines.append("")

    # Add report attachment info if provided
    if config.attach_report:
        header_lines.append("**Report Bundle**:")
        header_lines.append(f"- File: `{config.attach_report.filename}`")
        header_lines.append(f"- Size: {config.attach_report.size_bytes:,} bytes")
        header_lines.append(f"- Path: `{config.attach_report.path}`")
        header_lines.append("")
        header_lines.append(
            "*Note: Report bundle contains plan, environment info, and execution logs.*"
        )
        header_lines.append("")

    # Determine if content should be wrapped in details
    content_lines = config.plan_content.strip().split("\n")
    should_use_details = config.use_details and len(content_lines) > 15

    # Build sync block content
    if should_use_details:
        sync_block_lines = [
            "<!-- autorepro:begin plan schema=1 -->",
            "<details>",
            "<summary>ðŸ“‹ Reproduction Plan (click to expand)</summary>",
            "",
            config.plan_content.rstrip(),
            "",
            "</details>",
            "<!-- autorepro:end plan -->",
        ]
    else:
        sync_block_lines = [
            "<!-- autorepro:begin plan schema=1 -->",
            config.plan_content.rstrip(),
            "<!-- autorepro:end plan -->",
        ]

    # Add generation timestamp
    timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ")
    footer_lines = [
        "",
        f"Generated by [AutoRepro](https://github.com/autorepro/autorepro) on {timestamp}",
        f"<!-- generated: {timestamp} -->",
    ]

    # Combine all parts
    all_lines = header_lines + sync_block_lines + footer_lines
    return "\n".join(all_lines)


def find_synced_block(text: str) -> tuple[int, int] | None:
    """
    Find the autorepro sync block boundaries in text.

    Args:
        text: Text to search

    Returns:
        Tuple of (start_index, end_index) if found, None otherwise.
        Indices point to character positions of the begin/end tags.
    """
    # Look for the sync block tags
    begin_pattern = r"<!-- autorepro:begin plan schema=1 -->"
    end_pattern = r"<!-- autorepro:end plan -->"

    begin_match = re.search(begin_pattern, text)
    if not begin_match:
        return None

    end_match = re.search(end_pattern, text[begin_match.end() :])
    if not end_match:
        return None

    return begin_match.start(), begin_match.end() + end_match.end()


def replace_synced_block(existing_text: str, new_plan_content: str) -> str:
    """
    Replace the synced block content in existing text.

    Args:
        existing_text: The existing text with sync block
        new_plan_content: New plan content to insert

    Returns:
        Updated text with replaced sync block
    """
    block_bounds = find_synced_block(existing_text)
    if not block_bounds:
        # If no existing sync block, append new block
        new_sync_block = f"""
<!-- autorepro:begin plan schema=1 -->
{new_plan_content.rstrip()}
<!-- autorepro:end plan -->"""
        return existing_text.rstrip() + new_sync_block

    start_idx, end_idx = block_bounds

    # Replace just the sync block content
    new_sync_block = (
        f"<!-- autorepro:begin plan schema=1 -->\n{new_plan_content.rstrip()}\n"
        "<!-- autorepro:end plan -->"
    )

    return existing_text[:start_idx] + new_sync_block + existing_text[end_idx:]


def find_autorepro_content(content_list: list[dict[str, Any]]) -> dict[str, Any] | None:
    """
    Find existing autorepro content in list of comments or PR data.

    Args:
        content_list: List of content objects (comments, etc.) from GitHub

    Returns:
        Content object if found, None otherwise
    """
    for content in content_list:
        body = content.get("body", "")
        if "<!-- autorepro:begin plan schema=1 -->" in body:
            return content
    return None


def _extract_title_from_content(plan_content: str, format_type: str) -> str:
    """Extract title from plan content."""
    if format_type == "json":
        try:
            plan_data = json.loads(plan_content)
            return plan_data.get("title", "Issue Reproduction Plan")
        except json.JSONDecodeError:
            return "Issue Reproduction Plan"
    else:
        # Extract title from markdown
        lines = plan_content.split("\n")
        title_line = next(
            (line for line in lines if line.startswith("# ")),
            "# Issue Reproduction Plan",
        )
        return title_line[2:].strip()


def build_cross_reference_links(
    context: Literal["issue", "pr"] = "issue",
    *,
    link_issue: int | None = None,
    link_pr: int | None = None,
) -> list[str]:
    """
    Build list of cross-reference links.

    Args:
        context: Context for linking ('issue' or 'pr')
        link_issue: Issue number to link to
        link_pr: PR number to link to

    Returns:
        List of formatted cross-reference links
    """
    links = []

    if context == "pr" and link_issue:
        links.append(f"Relates to #{link_issue}")
    elif context == "issue" and link_pr:
        links.append(f"Relates to #{link_pr}")

    return links
