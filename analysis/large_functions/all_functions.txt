autorepro/sync.py:24:def render_sync_comment(
autorepro/sync.py:124:def find_synced_block(text: str) -> tuple[int, int] | None:
autorepro/sync.py:150:def replace_synced_block(existing_text: str, new_plan_content: str) -> str:
autorepro/sync.py:181:def find_autorepro_content(content_list: list[dict[str, Any]]) -> dict[str, Any] | None:
autorepro/sync.py:198:def _extract_title_from_content(plan_content: str, format_type: str) -> str:
autorepro/sync.py:216:def build_cross_reference_links(
autorepro/core/planning.py:37:def normalize(text: str) -> str:
autorepro/core/planning.py:62:def _extract_regex_keywords(text: str) -> set[str]:
autorepro/core/planning.py:71:def _collect_plugin_keywords() -> set[str]:
autorepro/core/planning.py:81:def _extract_plugin_keywords(text: str, plugin_keywords: set[str]) -> set[str]:
autorepro/core/planning.py:98:def extract_keywords(text: str) -> set[str]:
autorepro/core/planning.py:119:def safe_truncate_60(text: str) -> str:
autorepro/core/planning.py:144:def _determine_ecosystems_to_include(keywords: set[str]) -> set[str]:
autorepro/core/planning.py:161:def _collect_active_rules(
autorepro/core/planning.py:176:def _calculate_rule_score(
autorepro/core/planning.py:228:def _build_rationale(candidate: dict) -> str:
autorepro/core/planning.py:244:def _sort_candidates(candidates: list[dict]) -> list[dict]:
autorepro/core/planning.py:257:def suggest_commands(
autorepro/env.py:16:def python_bin() -> str:
autorepro/env.py:74:def default_devcontainer() -> dict[str, str | dict[str, dict[str, str]]]:
autorepro/env.py:89:def _shorten_value(value_str: str, max_length: int | None = None) -> str:
autorepro/env.py:106:def json_diff(old: dict[str, Any], new: dict[str, Any]) -> list[str]:
autorepro/env.py:168:def write_devcontainer(
autorepro/config/models.py:194:def get_config() -> AutoReproConfig:
autorepro/config/models.py:203:def reset_config() -> None:
autorepro/io/github.py:20:def detect_repo_slug() -> str:
autorepro/io/github.py:55:def ensure_pushed(head_branch: str) -> bool:
autorepro/io/github.py:100:def find_existing_draft(head_branch: str, gh_path: str = "gh") -> int | None:
autorepro/io/github.py:139:def get_pr_details(pr_number: int, gh_path: str = "gh") -> dict[str, Any]:
autorepro/io/github.py:179:def create_pr_comment(
autorepro/io/github.py:230:def update_pr_body(
autorepro/io/github.py:281:def add_pr_labels(
autorepro/io/github.py:320:def create_or_update_pr(
autorepro/io/github.py:453:def get_current_pr_for_branch(branch_name: str, gh_path: str = "gh") -> int | None:
autorepro/io/github.py:495:def get_issue_comments(issue_number: int, gh_path: str = "gh") -> list[dict[str, Any]]:
autorepro/io/github.py:536:def create_issue_comment(
autorepro/io/github.py:587:def create_issue(
autorepro/io/github.py:655:def add_issue_labels(
autorepro/io/github.py:696:def add_issue_assignees(
autorepro/render/formats.py:13:def _parse_devcontainer_status(needs: list[str]) -> bool:
autorepro/render/formats.py:18:def _extract_section_from_rationale(
autorepro/render/formats.py:40:def _extract_tokens_from_text(text: str) -> list[str]:
autorepro/render/formats.py:61:def _extract_matched_keywords(rationale: str) -> list[str]:
autorepro/render/formats.py:69:def _extract_matched_languages(rationale: str) -> list[str]:
autorepro/render/formats.py:75:def _process_commands(commands: list[tuple[str, int, str]]) -> list[dict[str, Any]]:
autorepro/render/formats.py:89:def build_repro_json(
autorepro/render/formats.py:128:def build_repro_md(
autorepro/rules.py:59:def _load_plugin_rules() -> dict[str, list[Rule]]:
autorepro/rules.py:99:def get_rules() -> dict[str, list[Rule]]:
autorepro/utils/plan_processing.py:29:def process_plan_input(desc_or_file: str | None, repo_path: Path, min_score: int = 0) -> PlanData:
autorepro/utils/file_ops.py:145:def create_temp_file(content: str, suffix: str = "", encoding: str = "utf-8") -> Path:
autorepro/utils/github_api.py:14:def update_comment(
autorepro/utils/repro_bundle.py:16:def generate_plan_content(
autorepro/utils/cli_validation.py:133:def validate_and_exit(validator_result: str | None, exit_code: int = 2) -> None:
autorepro/utils/cli_validation.py:147:def validate_multiple(*validator_results: str | None, exit_code: int = 2) -> None:
autorepro/utils/process.py:176:def safe_subprocess_run(
autorepro/cli.py:38:def ensure_trailing_newline(content: str) -> str:
autorepro/cli.py:44:def temp_chdir(path: Path) -> Generator[None, None, None]:
autorepro/cli.py:54:def create_parser() -> argparse.ArgumentParser:
autorepro/cli.py:420:def cmd_scan(json_output: bool = False, show_scores: bool = False) -> int:
autorepro/cli.py:486:def cmd_plan(
autorepro/cli.py:724:def cmd_init(
autorepro/cli.py:822:def parse_env_vars(env_list: list[str]) -> dict[str, str]:
autorepro/cli.py:833:def load_env_file(env_file: str) -> dict[str, str]:
autorepro/cli.py:848:def cmd_exec(
autorepro/cli.py:1075:def cmd_pr(
autorepro/cli.py:1216:def main(argv: list[str] | None = None) -> int:
autorepro/pr.py:33:def build_pr_title(plan_data: dict[str, Any], is_draft: bool = True) -> str:
autorepro/pr.py:51:def build_pr_body(plan_content: str, format_type: str) -> str:
autorepro/pr.py:182:def generate_plan_data(
autorepro/pr.py:209:def update_pr_comment(
autorepro/pr.py:233:def upsert_pr_comment(
autorepro/pr.py:280:def upsert_pr_body_sync_block(
autorepro/pr.py:335:def generate_report_metadata_for_pr(
autorepro/issue.py:39:def render_issue_comment_md(
autorepro/issue.py:79:def build_cross_reference_links(
autorepro/issue.py:122:def generate_plan_for_issue(
autorepro/issue.py:149:def find_autorepro_comment(comments: list[dict[str, Any]]) -> dict[str, Any] | None:
autorepro/issue.py:162:def update_issue_comment(
autorepro/issue.py:186:def upsert_issue_comment(
autorepro/issue.py:234:def generate_report_metadata(
autorepro/detect.py:162:def collect_evidence(root: Path) -> dict[str, dict[str, object]]:
autorepro/detect.py:250:def detect_languages_with_scores(root: Path) -> list[str]:
autorepro/detect.py:265:def detect_languages(path: str) -> list[tuple[str, list[str]]]:
autorepro/report.py:36:def collect_env_info(repo: Path) -> str:
autorepro/report.py:99:def write_plan(repo: Path, desc_or_file: str | None, format_type: str) -> tuple[Path, str | bytes]:
autorepro/report.py:127:def maybe_exec(repo: Path, opts: dict[str, Any]) -> tuple[int, Path | None, Path | None]:
autorepro/report.py:320:def pack_zip(out_path: Path, files: dict[str, Path | str | bytes]) -> None:
